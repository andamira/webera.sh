#!/usr/bin/env bash
# shellcheck disable=SC2016
#
#          name : webera
#   description : a handy static website generator
#    repository : https://github.com/andamira/webera
#        author : José Luis Cruz © 2016-2017
#       license : MIT
__WEBERA_VERSION=0.1.72


#-------------------------------------------------------------------------------
# ::main
#
# > $@ : all the arguments passed to the script
#
webera::main() {


	## PRE-SETUP

	webera::check-compatibility

	local -ir __Time_stamp="$($__DATE '+%s%3N')" # [INC02]

	webera::setup-debug

	local Options_webera # the list of all webera options
	local __options_pre __options_post # temporary options storage
	# shellcheck disable=SC2034
	__options_pre=$(set -o posix ; set | $__AWK -F= '{print $1"="}' )


	## CONFIGURABLE GLOBAL OPTIONS

	# 1. Variables prefixed with `Opt_` are the configurable options.
	# 2. Options starting with underscore can't be configured from
	#    a config file|string, only using script flag arguments.
	# 3. Variables that don't have an argument associated can
	#    only be modified through a config file|string.
	# 4. Options can be referenced from the config file by removing
	#    the `Opt_` prefix, and case sensitivity is not enforced.

	# statuses
	local    _Opt_operational=false              # -trawn
	local    _Opt_do_process_templates=false     # -ta
	local    _Opt_do_process_templates=false     # -ta
	local    _Opt_do_process_resources=false     # -ra
	local    _Opt_do_preview_in_browser=false    # -w
	local    _Opt_do_generate_config_file=false  # -n

	# paths
	local     Opt_dir_templates=tem              # -T
	local     Opt_dir_resources=res              # -R
	local     Opt_dir_output=out                 # -O
	local     Opt_dir_build=build                # -B
	local    _Opt_config_file=.weberarc          # -F
	local    _Opt_config_string=""               # -S

	# delete output & build directories
	local    _Opt_do_delete_dir_output=true      # -d
	local     Opt_do_delete_dir_build=true

	# log
	local     Opt_log_file=log.txt               # -G
	local    _Opt_do_clear_log=false             # -c
	local -i  Opt_log_level=0                    # -L [0-3]

	# web browser
	local     Opt_web_browser="firefox"          # -W
	local     Opt_server_type="python"           # -S
	local     Opt_server_host="localhost"        # -H
	local -i  Opt_server_port=8192               # -P
	local     Opt_server_start=""
	local     Opt_server_stop=""

	# misc
	local    _Opt_do_display_usage=false         # -h
	local    _Opt_do_print_vars=false            # -_
	local -i  Opt_nesting_max=8


	## POST-SETUP

	# shellcheck disable=SC2034
	__options_post="$(set -o posix ; set | $__SED '/^'\''/d' )"
	# save the list of the default options
	webera::setup-options __options_pre __options_post Options_webera


	## NON-CONFIGURABLE GLOBAL DATA

	# arrays
	local -A Options_args_array  # the options received as script arguments
	local -A Defined_cmd_map     # the configured custom defined commands

	local -i Nesting_level=0  # current nesting level, when including files

	local Config_whole  # all the configuration is saved here after being read
	local Log_presaved  # log messages are saved here before logfile is ready


	## STRING CONSTANTS

	local -r __Date_start="$($__DATE '+%Y-%m-%d %H:%M:%S' \
		-d @"${__Time_stamp:0:10}")" # [INC03]

	# whitespace indentation and headline
	local -r __In="  " __In2="    " __In3="      "
	local -r __Hl='------------------------------------------------------'

	# reusable regexp patterns
	local -r __Ws="[[:space:]]" # whitespace
	local -r __Sed_trim_ws="s/^$__Ws*//;s/$__Ws*$//"
	local -r __Sed_del_comments="/^$__Ws*#.*/d" # starting in #
	local -r __Sed_del_empty_lines="/^$__Ws*$/d"
	local -r __Sed_join_split_lines=':x; /\\$/ {N; s/\\\n//; tx}' # ending in \


	## MAIN LOGIC

	webera::log "\n===============[$__Date_start]==============@\n"

	webera::parse-arguments "$@"

	# read the configuration files & string
	[[ $_Opt_config_file != "/etc/weberarc" ]] && webera::read-config file "/etc/weberarc"
	[[ $_Opt_config_file != "$HOME/.weberarc" ]] && webera::read-config file "$HOME/.weberarc"
	webera::read-config file "$_Opt_config_file"
	webera::read-config string '_Opt_config_string'

	webera::parse-config-options

	if [[ $_Opt_do_print_vars == true ]]; then
		webera::print-options; exit 0
	elif [[ $_Opt_do_display_usage == true || "$_Opt_operational" == false ]]; then
		webera::display-info usage
	fi

	webera::setup-log

	[[ $_Opt_operational == false ]] && exit 1

	webera::delete-directories

	webera::read-config-commands

	[[ $_Opt_do_process_resources == true ]] && webera::process-resources
	[[ $_Opt_do_process_templates == true ]] && webera::process-templates

	webera::log "Total elapsed time: $(webera::elapsed-time true)"

	[[ $_Opt_do_preview_in_browser == true ]] && webera::preview-website
	exit 0

} # ::main


#-------------------------------------------------------------------------------
# ::display-info
#
#   Displays usage or version information.
#
# > $1 [usage|version]
# ^ ::parse-arguments ::parse-config-options
#
webera::display-info() {

	case "$1" in
		usage)
			cat -- <<-ENDUSAGE
Usage: $(basename "$0") -[trawn] [other options]

> a handy static website generator <

INSTRUCTIONS

1. At least one OPERATIVE FLAG is needed in order for the script to run.
2. Mandatory arguments to long options, are mandatory for short options too.

OPERATIVE FLAGS              ...

  -t, --process-templates    process the templates
  -r, --process-resources    process the resources
  -a, --process-all          process both the templates and the resources
  -w  --preview              preview website in the web browser
  -n  --new-config           generate a new configuration file

OPTION FLAGS                 ... (default value)

  -F, --file-config=FILE     indicate the configuration file ($_Opt_config_file)
  -C, --config=STRING        pass the configuration as a string ($_Opt_config_string)

  -T, --dir-templates=DIR    indicate the templates directory ($Opt_dir_templates)
  -R, --dir-resources=DIR    indicate the resources directory ($Opt_dir_resources)
  -O, --dir-output=DIR       indicate the output directory ($Opt_dir_output)
  -B, --dir-build=DIR        indicate the build directory ($Opt_dir_build)
  -d, --dont-delete-output   don't delete the output dir ($_Opt_do_delete_dir_output)

  -L, --log-level=LEVEL      log level [0=none|1|2|3] ($Opt_log_level)
  -c, --clear-log            clear the previous log file ($_Opt_do_clear_log)
  -G, --logfile=FILE         log file ($Opt_log_file)

  -W, --browser-bin=BIN      web browser binary ($Opt_web_browser)
  -S, --server-type=TYPE     server type [none|php|python|custom] ($Opt_server_type)
  -H, --server-host=HOST     server host ($Opt_server_host)
  -P, --server-port=PORT     port number ($Opt_server_port)

  -h, --help                 display this help and exit
      --version              show version info and exit

			ENDUSAGE
			;;

		version)
			cat -- <<-ENDVERSION
				webera v$__WEBERA_VERSION

				<https://github.com/andamira/webera>

				Copyright (C) 2016-2017 José Luis Cruz
				Released under the MIT license.

				Dependencies found:
				  $__SED, $__AWK, $__GREP, $__DATE
			ENDVERSION
			;;
		esac

} # ::display-info


#-------------------------------------------------------------------------------
# ::parse-arguments
#
#  Parses the arguments received by the script and sets/saves the options.
#
# > $@ : all the arguments passed to the script
# ^ ::main
#
webera::parse-arguments() {

	local OPTIND option value
	local optspec=':trawnF:C:T:R:O:B:dcL:G:W:S:H:P:_h-:'

	while getopts "$optspec" option; do
		case "$option" in

		-) # long option flags: http://stackoverflow.com/a/7680682/940200
			case "$OPTARG" in

			process-templates) webera::set-arg process-templates   ;;
			process-resources) webera::set-arg process-resources   ;;
			process-all)       webera::set-arg process-all         ;;
			preview)           webera::set-arg preview             ;;
			new-config)        webera::set-arg new-config          ;;

			file-config=*)
				webera::set-arg file-config   "${OPTARG#*=}"       ;;
			config=*)
				webera::set-arg config        "${OPTARG#*=}"       ;;
			dir-templates=*)
				webera::set-arg dir-templates "${OPTARG#*=}"       ;;
			dir-resources=*)
				webera::set-arg dir-resources "${OPTARG#*=}"       ;;
			dir-output=*)
				webera::set-arg dir-output    "${OPTARG#*=}"       ;;
			dir-build=*)
				webera::set-arg dir-build     "${OPTARG#*=}"       ;;

			dont-delete-output) webera::set-arg dont-delete-output ;;
			clear-log)          webera::set-arg clear-log          ;;

			log-level=*)
				webera::set-arg log-level     "${OPTARG#*=}"       ;;
			log-file=*)
				webera::set-arg log-file      "${OPTARG#*=}"       ;;

			browser-bin=*)
				webera::set-arg browser-bin   "${OPTARG#*=}"       ;;
			server-type=*)
				webera::set-arg server-type   "${OPTARG#*=}"       ;;
			server-host=*)
				webera::set-arg server-host   "${OPTARG#*=}"       ;;
			server-port=*)
				webera::set-arg server-port   "${OPTARG#*=}"       ;;

			help) webera::set-arg help ;;
			version) webera::set-arg version ;;

			*) [[ $OPTERR == 1 ]] && webera::set-arg "--$OPTARG" ;;
			esac ;;

		# short option flags

		t) webera::set-arg process-templates                       ;;
		r) webera::set-arg process-resources                       ;;
		a) webera::set-arg process-all                             ;;
		w) webera::set-arg preview                                 ;;
		n) webera::set-arg new-config                              ;;

		F) webera::set-arg file-config        "$OPTARG"            ;;
		C) webera::set-arg config             "$OPTARG"            ;;

		T) webera::set-arg dir-templates      "$OPTARG"            ;;
		R) webera::set-arg dir-resources      "$OPTARG"            ;;
		O) webera::set-arg dir-output         "$OPTARG"            ;;
		B) webera::set-arg dir-build          "$OPTARG"            ;;

		d) webera::set-arg dont-delete-output                      ;;
		c) webera::set-arg clear-log                               ;;

		L) webera::set-arg log-level          "$OPTARG"            ;;
		G) webera::set-arg log-file           "$OPTARG"            ;;

		W) webera::set-arg browser-bin        "$OPTARG"            ;;
		S) webera::set-arg server-type        "$OPTARG"            ;;
		H) webera::set-arg server-host        "$OPTARG"            ;;
		P) webera::set-arg server-port        "$OPTARG"            ;;

		h) webera::set-arg help ;;

		_) webera::set-arg _ ;;  # hidden print-options argument

		*) [[ $OPTERR != 1 || ${optspec:0:1} == ":" ]] &&
			webera::set-arg "-$OPTARG" ;;
		esac
	done
	shift $((OPTIND-1))

} # ::parse-arguments


#-------------------------------------------------------------------------------
# ::set-arg
#
#   Sets both short and long arguments, in a centralize manner.
#
# >  $1 : the common long name of the argument
# >  $2 : (optional) the value of the argument
# x 255 : unknown argument
# ^ ::parse-arguments
#
webera::set-arg() {

	local argument="$1" value="$2"

	case "$argument" in

	# OPERATIONAL flags
	process-templates)
		_Opt_operational=true
		webera::push-arg _Opt_do_process_templates    true     ;;
	process-resources)
	   _Opt_operational=true
	   webera::push-arg _Opt_do_process_resources     true     ;;
	process-all)
		_Opt_operational=true
		webera::push-arg _Opt_do_process_resources    true
		webera::push-arg _Opt_do_process_templates    true     ;;
	preview)
		_Opt_operational=true
		webera::push-arg _Opt_do_preview_in_browser   true     ;;
	new-config)
		_Opt_operational=true
		_Opt_do_generate_config_file=true
		webera::push-arg _Opt_do_generate_config_file true     ;;


	## OPTION FLAGS

	# Options whose name starts with an underscore `_` can only be set
	# via script arguments; they are not read from any configuration.

	file-config)
		_Opt_config_file="$value"
		webera::push-arg _Opt_config_file             "$value" ;;
	config)
		_Opt_config_string="$value"
		webera::push-arg _Opt_config_string           "$value" ;;
	clear-log)
		webera::push-arg _Opt_do_clear_log            true     ;;
	dont-delete-output)
		webera::push-arg _Opt_do_delete_dir_output    false    ;;

	# The following options can also be defined in configuration file,
	# but passing them as arguments to the script has a higher priority.

	dir-templates)
		webera::push-arg Opt_dir_templates            "$value" ;;
	dir-resources)
		webera::push-arg Opt_dir_resources            "$value" ;;
	dir-output)
		webera::push-arg Opt_dir_output               "$value" ;;
	dir-build)
		webera::push-arg Opt_dir_build                "$value" ;;
	log-level)
		webera::push-arg Opt_log_level                "$value" ;;
	log-file)
		webera::push-arg Opt_log_file                 "$value" ;;
	browser-bin)
		webera::push-arg Opt_web_browser              "$value" ;;
	server-type)
		webera::push-arg Opt_server_type              "$value" ;;
	server-host)
		webera::push-arg Opt_server_host              "$value" ;;
	server-port)
		webera::push-arg Opt_server_port              "$value" ;;
	help)
		_Opt_do_display_usage=true                             ;;
	version)
		webera::display-info version; exit 0                   ;;
	_)
		_Opt_do_print_vars=true                                ;;
	*)
		webera::log error "ERROR: unknow argument '$argument'"
		exit 255 ;; # TODO send to log
	esac

} # ::set-arg


# ::push-arg
#
#   Pushes a key to the array of options received as arguments.
#
# > $1 option key
# > $2 value received
# ^ ::set-arg
#
webera::push-arg() { Options_args_array[$1]="$2"; }


#-------------------------------------------------------------------------------
# ::setup-log
#
#   Sets up the log file and then writes all the pre-saved logs.
#
# ^ ::main
#
webera::setup-log() {

	local parsed_prelog

	if [[ $_Opt_do_clear_log == true ]]; then
		webera::log 3 warn "\nWarning: deleting previous log file '$Opt_log_file'"
		rm -- "$Opt_log_file" 2>/dev/null;
	fi

	# Restore the pre-saved log messages
	#
	# 1. filter out the lines with greater than current log level
	# 2. leave only the log message, discard the rest. TODO: restore warn|error
	# 3. bring back the newlines previously converted to BEL.
	# 4. replace the last `@` char, in the date header line. with the log level.
	#
	# shellcheck disable=SC2059
	parsed_prelog=$(printf "$Log_presaved" \
		| $__AWK -v log_level=$Opt_log_level -F '|' '$1<=log_level' \
		| cut -d'|' -f3- \
		| tr '\a' '\n' \
		| $__SED "s/====@$/====$Opt_log_level/" \
	)
	Log_presaved=false

	[[ -n $parsed_prelog ]] && webera::log "$parsed_prelog" # print what's left

} # ::setup-log


#-------------------------------------------------------------------------------
# ::log
#
#   Prints a message to the log file. Errors and warnings also to STDERR.
#
# > $1  : (optional) log_level_needed
# > $2  : (optional) log_type [warn|error]
# > $3+ : log message
# ^ (almost all functions)
#
# shellcheck disable=SC2059
webera::log() {

	local log_level_needed="$1" # First (optional) parameter
	local -ir log_level_min=1 log_level_max=3
	local -i log_level

	# must be an integer number
	if [[ $log_level_needed =~ ^[0-9]+$ ]]; then
		if [[ $log_level_needed -lt $log_level_min ]]; then
			log_level="$log_level_min"
		elif [[ $log_level_needed -gt $log_level_max ]]; then
			log_level="$log_level_max"
		else
			log_level="$log_level_needed"
		fi
		shift # prepare next positional parameter

	else # if not a number, use defaults
		log_level="$log_level_min"
	fi

	local log_type="$1" # Second (optional) parameter

	# must be the type
	case "$log_type" in
		error|warn)
			shift # prepare next positional parameter
			;;
		*) log_type="" ;;
	esac

	local __ifs="$IFS"; IFS=$''
	local log_msg="$*" # All that rewebera::mains is the log message
	IFS="$__ifs"

	if [[ $Log_presaved == false ]]; then
		if [[ $log_level -le $Opt_log_level ]]; then
			printf "$log_msg\n" >> "$Opt_log_file"
		fi
	else
		# Pre-save this log message as a single line
		#
		# 1. replace the newlines with a BEL
		# 2. put the log level and type at the beginning
		local log_msg_1line; log_msg_1line=$(printf "$log_msg" | tr '\n' '\a') || true
		Log_presaved+="\n$log_level|$log_type|$log_msg_1line"
	fi

	# Print errors and warnings to stderr [OPTIMIZE]
	if [[ $log_type == "error" || $log_type == "warn" ]]; then
		# 1. trim whitespace
		# 2. delete newlines
		# 3. print to STDERR
		printf "$log_msg" \
			| $__SED -e "$__Sed_trim_ws" \
			| tr -d '\n' \
			| $__AWK '{ print }' - >&2
	fi

} # ::log


#-------------------------------------------------------------------------------
# ::preview-website
#
#   Prepares the server commands, for previewing in the browser.
#
# x 5 : Server type not recognized
# ^ ::main (when the script received the `-r` flag)
#
webera::preview-website() {

	local cmd_browser

	case "$Opt_server_type" in
	python)
		Opt_server_start='pushd "$Opt_dir_output"; '
		Opt_server_start+='python -m SimpleHTTPServer $Opt_server_port'
		Opt_server_stop='kill $(pgrep -f "python -m SimpleHTTPServer")'
		;;
	php)
		Opt_server_start='php -S "$Opt_server_host:$Opt_server_port"'
		Opt_server_start+=' -t "$Opt_dir_output"'
		Opt_server_stop='kill $(pgrep -f "php -S $Opt_server_host")'
		;;
	none) # useful when not using `dir/index.html` structure
		Opt_server_start=""
		Opt_server_stop=""
		;;
	custom) # for when a server is already running, or custom Opt_server_start
		;;
	*)
		webera::log 2 error "ERROR: Not recognized "
			"Opt_server_type='$Opt_server_type'"
		exit 5
		;;
	esac

	printf 'Loading website in "%s"...\n' "$Opt_web_browser"

	if [[ $Opt_server_type == "none" ]]; then
		cmd_browser="$Opt_web_browser file://$($__READLINK -f $Opt_dir_output) &"
	else
		cmd_browser="$Opt_web_browser http://$Opt_server_host:$Opt_server_port &"
	fi

	sleep 1s && eval "$cmd_browser" >&2 2>/dev/null
	if [[ -n $Opt_server_start ]]; then
		printf '(Use CTRL+C to stop the "%s" web server)\n' \
			"$Opt_server_type"
		printf 'Opt_server_start=%s' "$Opt_server_start"
		eval "$Opt_server_stop >&2 2>/dev/null"; eval "$Opt_server_start"
	fi

} # ::preview-website


#-------------------------------------------------------------------------------
# ::delete-directories
#
#   Deletes Opt_dir_build, and Opt_dir_output if there is pending processing.
#
# ^ ::main
#
webera::delete-directories() {

	[[ $Opt_do_delete_dir_build == true ]] &&
		rm -rf -- "$Opt_dir_build" 2>/dev/null

	if [[ $_Opt_do_delete_dir_output == true ]] &&
		[[ $_Opt_do_process_resources == true \
		|| $_Opt_do_process_templates == true ]]; then
			rm -rf -- "$Opt_dir_output" 2>/dev/null
	fi

} # ::delete-directories


#-------------------------------------------------------------------------------
# ::read-config
#
#   Reads the configuration from a file or a string,
#   and joins it all together into $Config_whole.
#
# > $1 : [file|string] the origin of the configuration.
# > $2 : $config_pointer is the file name when the origin is a file,
#        or the variable name when the origin is a string.
# x 10 : unknown config type
# ^ ::main
#
webera::read-config() {

	local config_orig="$1" config_pointer="$2"
	local read_config  # the configuration read from $config_pointer

	if [[ $config_orig == "string" ]]; then
		if [[ -n ${!config_pointer} ]]; then # string's not empty
			webera::log 3 "Reading settings passed as an argument."
			read_config="$(printf '%s' "${!config_pointer}" \
				| $__SED -e "$__Sed_trim_ws" \
				| $__SED -e "$__Sed_del_comments" -e "$__Sed_del_empty_lines" \
				| $__SED -e "$__Sed_join_split_lines" \
			)"$'\n'
			Config_whole+="$read_config"
			webera::store-options-from-config strn "" "$read_config"
		fi

	elif [[ $config_orig == "file" ]]; then

		if [[ -f $config_pointer ]]; then # the file exists

			if [[ $_Opt_do_generate_config_file == true ]] ; then
				webera::log 2 warn "Warning: automatic override of an existing " \
					"config file ('$config_pointer') is not permitted."
				return 0
			fi

			webera::log 3 "Reading settings from file '$config_pointer'"
			read_config="$(sed -e "$__Sed_trim_ws" "$config_pointer" \
				| $__SED -e "$__Sed_del_comments" -e "$__Sed_del_empty_lines" \
				| $__SED -e "$__Sed_join_split_lines" \
			)"$'\n'
			Config_whole+="$read_config"
			webera::store-options-from-config file "$config_pointer" "$read_config"

		else # config file doesn't exist

			# it's the config file of the project
			if [[ $config_pointer == "$_Opt_config_file" ]]; then
				# stop if printing debug info
				[[ $_Opt_do_print_vars == true ]] && return 0

				if [[ $_Opt_do_generate_config_file == true ]]; then
					webera::generate-config-file
				else
					webera::log 3 warn "Warning: project's config file " \
						"'$_Opt_config_file' doesn't exist."
				fi
			fi
		fi
	else
		webera::log error "Error: unknown config type"
		exit 10
	fi

} # ::read-config


#-------------------------------------------------------------------------------
# ::parse-config-options
#
#   Parses the configuration options and overrides the default options with:
#   1 - the joint configuration and 2 - the passed arguments, in that order.
#
# ^ ::main
#
webera::parse-config-options() {

	local settings_list
	local setting
	local option_name
	local setting_value
	local setting_previous

	# Create a list of all the 'config' operations
	settings_list="$(printf '%s' "$Config_whole" \
		| $__GREP "^$__Ws*config$__Ws*:" )"

	if [[ -n $settings_list ]]; then
		webera::log "\nConfiguring settings...\n$__Hl"

		local __ifs="$IFS"; IFS=$'\n'
		for setting in $settings_list; do
			# TODO: sanitize received data
			option_name=$(printf '%s' "$setting" \
				| cut -d':' -f2 \
				| $__SED -e "$__Sed_trim_ws")
			setting_value=$(printf '%s' "$setting" \
				| cut -d':' -f3- \
				| $__SED -e "$__Sed_trim_ws")

			[[ -n ${!option_name} ]] &&
				setting_previous="(previous=${!option_name})"

			webera::log "${__In}setting: $option_name=$setting_value " \
				"$setting_previous"

			# Read (only public) options from file
			if [[ $setting != _* ]]; then
				# Override the global option with the parsed config option
				printf -v "Opt_${option_name,,}" '%s' "$setting_value"
			fi
		done
		IFS="$__ifs"
	fi

	local opt_list # temporary storage for the argument options
	local opt; for opt in "${!Options_args_array[@]}"; do
		# Override the global option with the parsed argument
		printf -v "$opt" '%s' "${Options_args_array[$opt]}"
		# Format the line appropriately
		opt_list+="$opt=${Options_args_array[$opt]}"$'\n'
	done
	# Mass-sanitize and append the parsed arguments to the global options list
	Options_webera+=$'\n'"$(webera::sanitize-options "$opt_list" args)"

} # ::parse-config-options


#-------------------------------------------------------------------------------
# ::generate-config-file
#
#   Generates a config file, writing down the options modified via arguments.
#
# ^ ::main (when the script received the `-n` flag)
#
webera::generate-config-file() {

	local option; for option in "${!Options_args_array[@]}"; do
		if [[ $option != _* ]]; then # Only write public options
			local opt=${option#Opt_} # remove `Opt_` prefix
			# Save current option to the new config file (UPPERCASE)
			printf '%s\n' \
				"config : ${opt^^} : ${Options_args_array[$option]}" \
				>> "$_Opt_config_file"
		fi
	done
	touch "$_Opt_config_file" # make sure (even an empty) file is created

} # ::generate-config-file


#-------------------------------------------------------------------------------
# ::read-config-commands
#
#   Reads the configuration commands for processing templates and resources.
#
# ^ ::main
#
webera::read-config-commands() {

	local commands_list
	local commands_num
	local cmd
	local command_name
	local command_action

	commands_list="$(printf '%s' "$Config_whole" | $__GREP "^$__Ws*command$__Ws*:" )"

	if [[ -n $commands_list ]]; then
		commands_num=$(printf '%s\n' "$commands_list" | wc -l )
		webera::log "\nParsing commands...\n$__Hl"
		webera::log "${__In}Found $commands_num defined command:"
	else return 0; fi

	local __ifs="$IFS"; IFS=$'\n'
	for cmd in $commands_list; do # [OPTIMIZE]
		command_name=$(printf '%s' "$cmd" \
			| cut -d':' -f2 \
			| $__SED -e "$__Sed_trim_ws" )
		command_action=$(printf '%s' "$cmd" \
			| cut -d':' -f3- \
			| $__SED -e "$__Sed_trim_ws" )

		Defined_cmd_map["$command_name"]="$command_action"

		webera::log 2 "${__In}$command_name='$command_action'"
	done
	IFS="$__ifs"

} # ::read-config-commands


#-------------------------------------------------------------------------------
# ::process-resources
#
#   Parses the configuration and executes the resource operations.
#
# < 8 : no resources directory found
# ^ ::main (when the script received the `-r` flag)
#
webera::process-resources() {

	local oper_list_res  # list of operations over resources
	local oper_num       # the number of operations in $oper_list_res
	local oper           # single operation from $oper_list_res
	local oper_type      # the type of operation $oper is
	local oper_orig      # the operation origin, tipically the origin file
	local oper_targ      # the operation target, tipically the target file
	local oper_cmd       # the command if $oper_type is a custom operation

	webera::log "\nProcessing resources...\n$__Hl"

	if [[ ! -d $Opt_dir_resources ]]; then
		webera::log error "No resources dir '$Opt_dir_resources' found."
		return 8
	fi

	oper_list_res="$(printf '%s' "$Config_whole" \
		| $__GREP "^$__Ws*resource$__Ws*:" )"
	oper_num=$(printf '%s\n' "$oper_list_res" \
		| $__SED "$__Sed_del_empty_lines" \
		| wc -l )
	webera::log "${__In}Found $oper_num operations on resources:"

	local __ifs="$IFS"; IFS=$'\n'
	for oper in $oper_list_res; do # [OPTIMIZE]
		oper_type=$(printf '%s' "$oper" \
			| cut -d':' -f2 \
			| $__SED -e "$__Sed_trim_ws" )
		oper_orig=$(printf '%s' "$oper" \
			| cut -d':' -f3 \
			| $__SED -e "$__Sed_trim_ws" )
		oper_targ=$(printf '%s' "$oper" \
			| cut -d':' -f4 \
			| $__SED -e "$__Sed_trim_ws" )

		webera::log "${__In}$oper_type: $oper_orig > $oper_targ"

		if [[ ! -e "$Opt_dir_resources/$oper_orig" ]]; then
			webera::log error "${__In}ERROR: '$oper_orig' don't exist"
			continue # XXX do break instead?
		fi

		case "$oper_type" in
		"copy")
			mkdir -p -- "$Opt_dir_output/$Opt_dir_resources/$(dirname "$oper_targ")"
			cp -r -- "$Opt_dir_resources/$oper_orig" \
				"$Opt_dir_output/$Opt_dir_resources/$oper_targ"
			;;
		*)
			# On custom cmds, {PATHS} tags are adapted for resources
			if [[ -n ${Defined_cmd_map[$oper_type]} ]]; then

				oper_cmd=$(printf '%s' "${Defined_cmd_map[$oper_type]}" \
					| $__SED "s|{ORIGIN}|$Opt_dir_resources/$oper_orig|g" \
					| $__SED "s|{BUILD}|$Opt_dir_build/$oper_orig|g" \
					| $__SED "s|{TARGET}|$Opt_dir_output/$Opt_dir_resources/$oper_targ|g")

				# Create target paths
				if [[ ${Defined_cmd_map[$oper_type]} == *"{BUILD}"* ]]; then
					mkdir -p -- "$(dirname "$Opt_dir_build/$oper_targ")"
				fi
				if [[ ${Defined_cmd_map[$oper_type]} == *"{TARGET}"* ]]; then
					mkdir -p -- "$(dirname \
						"$Opt_dir_output/$Opt_dir_resources/$oper_targ")"
				fi

				webera::log 3 "${__In}Executing: $oper_cmd"
				eval "$oper_cmd"
			else
				webera::log error \
					"${__In}ERROR: operation '$oper_type' not recognized"
			fi
			;;
		esac
	done
	IFS="$__ifs"

} # ::process-resources


#-------------------------------------------------------------------------------
# ::process-templates
#
#   Parses the configuration and executes the template operations.
#
# < 9 : no templates directory found
# ^ ::main (when the script received the `-t` flag)
#
webera::process-templates() {

	local oper_list_tem  # list of operations over templates
	local oper_num       # the number of operations in $oper_list_tem
	local oper           # single operation from $oper_list_tem
	local oper_type      # the type of operation $oper is
	local oper_orig      # the operation origin, tipically the origin file
	local oper_targ      # the operation target, tipically the target file
	local oper_cmd       # the command if $oper_type is a custom operation

	webera::log "\nProcessing templates...\n$__Hl"

	if [[ ! -d $Opt_dir_templates ]]; then
		webera::log error "No templates dir '$Opt_dir_templates' found."
		return 9
	fi

	oper_list_tem="$(printf '%s' "$Config_whole" \
		| $__GREP "^$__Ws*template$__Ws*:" )"

	oper_num=$(printf '%s\n' "$oper_list_tem" \
		| $__SED "$__Sed_del_empty_lines" \
		| wc -l )
	webera::log "${__In}Found $oper_num operations on templates:"

	local __ifs="$IFS"; IFS=$'\n'
	for oper in $oper_list_tem; do
		oper_type=$(printf '%s' "$oper" \
			| cut -d':' -f2 \
			| $__SED -e "$__Sed_trim_ws" )
		oper_orig=$(printf '%s'  "$oper" \
			| cut -d':' -f3 \
			| $__SED -e "$__Sed_trim_ws" )
		oper_goal=$(printf '%s' "$oper" \
			| cut -d':' -f4 \
			| $__SED -e "$__Sed_trim_ws" )

		webera::log "${__In}$oper_type: $oper_orig > $oper_goal"

		case "$oper_type" in
		"route")
			if [[ -n $oper_orig && -n $oper_goal ]]; then
				# A path ending in `/`, will be a dir_name/index.html
				if [[ $oper_goal == */ ]]; then
					mkdir -p -- "${Opt_dir_output}/${oper_goal}"
					webera::render-template "$oper_orig" > \
						"${Opt_dir_output}/${oper_goal}/index.html"
				else
					mkdir -p -- "$(dirname "${Opt_dir_output}/${oper_goal}")"
					webera::render-template "$oper_orig" > \
						"${Opt_dir_output}/${oper_goal}"
				fi
			else
				webera::log error "${__In}ERROR: missing arguments for" \
					"'template:route' operation"
			fi
			;;

		*)
			# On custom cmds, the {PATHS} tags are adapted for templates
			if [[ -n ${Defined_cmd_map[$oper_type]} ]]; then

				oper_cmd=$(printf '%s' "${Defined_cmd_map[$oper_type]}" \
					| $__SED "s|{ORIGIN}|$Opt_dir_templates/$oper_orig|g" \
					| $__SED "s|{BUILD}|$Opt_dir_build/$oper_orig|g" \
					| $__SED "s|{TARGET}|$Opt_dir_output/$oper_goal|g" )

				# Create target paths
				[[ ${Defined_cmd_map[$oper_type]} == *"{BUILD}"* ]] &&
					mkdir -p -- "$(dirname "$Opt_dir_build/$oper_goal")"
				[[ ${Defined_cmd_map[$oper_type]} == *"{TARGET}"* ]] &&
					mkdir -p -- \
						"$(dirname "$Opt_dir_output/$Opt_dir_resources/$oper_goal")"

				webera::log 3 "${__In}Executing: $oper_cmd"
				eval "$oper_cmd"
			else
				webera::log error \
					"${__In}ERROR: operation '$oper_type' not recognized"
			fi
			;;
		esac
	done
	IFS="$__ifs"

} # ::process-templates


#-------------------------------------------------------------------------------
# ::parse-template-includes
#
#   Recursively parses a template searching for include directives,
#   joining all the included parts together in a single template.
#
# > $1 : the path to the template file to process
# <  7 : No template found
# x  3 : Maximum nesting level overflow
# ^ ::render-template
# g __GREP __Ws __In __In2 Opt_nesting_max Opt_dir_templates
#
webera::parse-template-includes() {

	local template_file=$1    # the path can be relative to the parent,
	                          # `./*` or an absolute path `/*` or relative
	                          # to the templates (or build) directory.

	local dir_parent=${dir_parent:-} # where the parent template is located

	local template_content    # contents of $template_file
	local directives_include  # the %include directives in $template_content
	local directive           # one element in $directives_include
	local inc_file_name       # file name in $directive
	local inc_file_content    # content of $inc_file_name

	((Nesting_level++))

	if [[ $Nesting_level -gt $Opt_nesting_max ]]; then
		webera::log error "${__In}ERROR: max nesting level ($Opt_nesting_max)" \
			" reached for template '$template_file'"
		exit 3
	fi

	# is path relative to the parent's template?
	if [[ $template_file == ./* || $template_file == ../* ]]; then
		template_file="$dir_parent/$template_file"

	# if not, and path is not absolute either, then it must be
	# relative to the templates directory (or the build directory)
	elif [[ $template_file != /* ]]; then
		# If the template is found in the build directory it takes precedence
		if [[ -f "$Opt_dir_build/$template_file" ]]; then
			template_file="$Opt_dir_build/$template_file"
		else
			template_file="$Opt_dir_templates/$template_file"
		fi
	fi

	if [[ -f $template_file ]]; then
		# Read the template while translating newlines to form feed chars
		template_content="$(tr '\n' '\f' <"$template_file")"
	else
		webera::log error "${__In}ERROR: No template found '$template_file'"
		return 7
	fi

	directives_include=$($__GREP -Po "<!--$__Ws*%include$__Ws*:.*?-->" \
		"$template_file") # [INC01]

	# Remove duplicates, since references will be mass-replaced
	if [[ -n $directives_include ]]; then
		directives_include=$(printf '%s' "$directives_include" | uniq)
	fi

	dir_parent="$(dirname "$template_file")"

	# Process the includes
	local __ifs="$IFS"; IFS=$'\n'
	for directive in $directives_include; do
		inc_file_name=$(webera::get-directive-content "$directive" '%include')
		webera::log 2 "${__In2}include: '$inc_file_name'"

		# Parse included template for deeper includes
		inc_file_content="$(webera::parse-template-includes "${inc_file_name}")"

		# Mass-replace directive with template contents
		template_content="${template_content//$directive/$inc_file_content}"
	done
	IFS="$__ifs"

	((Nesting_level--))

	printf '%s' "$template_content"

} # ::parse-template-includes


#-------------------------------------------------------------------------------
# ::render-template
#
#   Parses the template, processes the directives and renders the html file.
#
# > $1 : template_file_name
# ^ ::process-templates (when parsing the 'route' command)
# g __AWK __GREP __SED __Ws __In2 __In3
#
webera::render-template() {

	local template_file_name="$1"

	local template_text      # the content of the template (after inclusions)
	local directives_set     # a list of the %set directives
	local directives_cmd     # a list of the %cmd directives
	local directives_setcmd  # a list of the %setcmd directives
	local directive          # current directive being parsed
	local set_var_val
	local set_var
	local set_value
	local cmd
	local cmd_output
	local set_cmd_var
	local set_cmd_value
	local set_cmd
	local set_cmd_output
	local -i cmd_output_len
	local -ir __max_output_len=50 # in characters

	template_text="$(webera::parse-template-includes "$template_file_name")"

	# text comments
	#
	# <!-- // Comment -->
	#
	# NOTE: Doesn't remove any empty newline it leaves
	template_text=$(printf '%s' "$template_text" \
		| $__SED -re "s/<!--$__Ws*\/\/.*?-->\x0c?//g")

	local __ifs="$IFS"; IFS=$'\n'

	# set variables
	#
	# <!-- %set : VARIABLE=something -->
	# <!-- @VARIABLE -->
	#
	directives_set=$(printf '%s' "$template_text" \
		| $__GREP -Po "<!--$__Ws*%set$__Ws*:.*?-->") # [INC01]

	for directive in $directives_set; do
		set_var_val=$(webera::get-directive-content "$directive" '%set')
		set_var="${set_var_val%%=*}"
		set_value="${set_var_val#*=}"

		webera::log 3 "${__In3}set: $set_var = $set_value"

		# remove the %set directive
		template_text=$(printf '%s' "$template_text" \
			| $__SED -e "s/$directive\x0c\?//g")

		# replace the @variable directive with the value
		template_text=$(printf '%s' "$template_text" \
			| $__SED -e "s/<!--$__Ws*@$set_var$__Ws*-->\x0c\?/$set_value/g")
	done

	# execute commands, render output
	#
	# <!-- %cmd : ls -l -->
	#
	directives_cmd=$(printf '%s' "$template_text" \
		| $__GREP -Po "<!--$__Ws*%cmd$__Ws*:.*?-->") # [INC01]

	for directive in $directives_cmd ; do
		cmd=$(webera::get-directive-content "$directive" '%cmd')
		cmd_output=$(eval "$cmd")
		webera::log 3 "${__In2}cmd: $cmd"

		cmd_output_len=$(printf "%s" "$cmd_output" | wc -c)

		if [[ $cmd_output_len -le $__max_output_len ]]; then
			webera::log 3 "${__In3}=: $cmd_output"
		else
			webera::log 3 "${__In3}=: $(printf '%s' "$cmd_output" \
				| tr '\n' ' ' \
				| head -c$__max_output_len) (...) +" \
				"$((cmd_output_len-__max_output_len)) chars"
		fi

		# Substitute the directive in the template with the command output
		# http://stackoverflow.com/a/40749641/940200
		template_text=$($__AWK -v repl="$cmd_output" 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) repl substr($0, n+length(a))
			} 1' <(printf '%s\n' "$directive") <(printf '%s' "$template_text")
		)
	done

	# set variables to commands output
	#
	# <!-- %setcmd : VARIABLE=ls -l -->
	# <!-- @VARIABLE -->
	#
	directives_setcmd=$(printf '%s' "$template_text" \
		| $__GREP -Po "<!--$__Ws*%setcmd$__Ws*:.*?-->") # [INC01]

	for directive in $directives_setcmd; do
		set_cmd=$(webera::get-directive-content "$directive" '%setcmd')
		set_cmd_var="${set_cmd%%=*}"
		set_cmd_value="${set_cmd#*=}"
		# get the command output, escaping the sed special characters
		set_cmd_output=$(eval "$set_cmd_value" | $__SED -e 's/[\/&]/\\&/g' )

		webera::log 3 "${__In2}setcmd: $set_cmd_var = $set_cmd_value"

		# Delete the directive from the template
		template_text=$($__AWK 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) substr($0, n+length(a))
			} 1' <(printf '%s' "$directive") <(printf '%s' "$template_text")
		)

		template_text=$(printf '%s' "$template_text" \
			| $__SED -e "s/<!--$__Ws*@$set_cmd_var$__Ws*-->\x0c\?/$set_cmd_output/g")
	done

	IFS="$__ifs"

	webera::log 3 ""

	# Print the template, translating back all form-feeds to newlines
	printf "%s" "$template_text" | tr '\f' '\n'

} # ::render-template


#-------------------------------------------------------------------------------
# ::get-directive-content
#
#   Checks for dependencies and displays pertinent information.
#
# > $1 : whole directive
# > $2 : directive identifier (e.g. %include)
# ^ ::render-template
#
webera::get-directive-content() {

	printf '%s' "$1" \
		| $__SED -n -e "s/<\!--$__Ws*$2$__Ws*:$__Ws*\(.*\)$__Ws*-->/\1/p" \
		| $__SED -e "s/$__Ws*$//"

} # ::get-directive-content


#-------------------------------------------------------------------------------
# ::check-compatibility
#
#   Checks for dependencies and displays pertinent information.
#
# x 6 : bash version too old
# ^ ::main
#
webera::check-compatibility() {

	# Bash version >= 4
	if [[ ${BASH_VERSINFO[0]} -lt 4 ]]; then
		printf '%s\n' "Bash version >=4 needed. Current version is $BASH_VERSION"

		if [[ $(uname) == 'Darwin' ]]; then
			printf 'You can install it with Brew (http://brew.sh)\n like this:'
			printf 'brew install bash\n'
		fi
		exit 6
	fi

	# prefer the GNU version of the Unix commands (specially in Mac OS X)
	__SED="$(webera::find-gnu-cmd sed)"
	__AWK="$(webera::find-gnu-cmd  awk)"
	__GREP="$(webera::find-gnu-cmd grep)"
	__DATE="$(webera::find-gnu-cmd date)"
	__READLINK="$(webera::find-gnu-cmd readlink)"

} # ::check-compatibility


#-------------------------------------------------------------------------------
# ::find-gnu-cmd
#
#   Returns the resolved command, preferring the GNU versions
#   and falling back to the standard version when not found.
#
# > $1 : command binary
# ^ ::check-compatibility
#
webera::find-gnu-cmd() {

	local cmd_default="$1"
	local cmd_gnu="g$cmd_default"

	if [[ $(which "$cmd_gnu" 2> /dev/null) ]]; then
		printf '%s' "$cmd_gnu"
	else
		printf '%s' "$cmd_default"
	fi

} # ::find-gnu-cmd


#-------------------------------------------------------------------------------
# ::setup-debug
#
#   Enables xtrace if WEBERA_DEBUG has been defined, and sets a nice formatting.
#
# ^ ::main
#
webera::setup-debug() {

	local ps4_date='[$(($($__DATE "+%s%3N")-__Time_stamp))ms]' # [INC02]
	local ps4_line='L$LINENO'
	local ps4_func='${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

	[[ -n $WEBERA_DEBUG ]] && set -o xtrace && set -o verbose &&
		export PS4="+ $ps4_date $ps4_line $ps4_func"

} # ::setup-debug


#-------------------------------------------------------------------------------
# ::print-options
#
#   Prints all the webera configurable options.
#
# ^ ::main
#
webera::print-options() { printf '%s\n' "$Options_webera"; }


#-------------------------------------------------------------------------------
# ::setup-options
#
#   Saves the default options. Unsets $1 & $2.
#
# > $1 : (by ref.) lines to ignore
# > $2 : (by ref.) lines to ignore and to keep
# > $3 : (by ref.) where to keep the wanted lines
# ^ ::main
#
webera::setup-options() {

	# return the lines not common to both lists $1 & $2
	local result; result=$( $__GREP -vFf \
		<(printf '%s' "${!1}") <(printf '%s' "${!2}") )

	# save the result in $3 after sanitizing the names
	printf -v "$3" '%s' \
		"$(webera::sanitize-options "$result" vdef)"

	unset "$1"; unset "$2"

} # ::setup-options


#-------------------------------------------------------------------------------
# ::sanitize-options
#
#   Removes the Opt_ prefix, UPPERCASES `variable=`, and adds the origin prefix.
#
# > $1 : supports multiple lines in `variable=value` format
# > $2 : prefix indicating the origin of the variable [vdef|args|file|strn]
# ^ ::parse-config-options ::setup-options
#
webera::sanitize-options() {

	$__SED -e 's/^\(_\?\)Opt_/\1/' \
		-e 's/[^=]*/\U&/' \
		-e "s/^/[$2]::/" \
		<(printf '%s' "$1")

} # ::sanitize-options


#-------------------------------------------------------------------------------
# ::store-options-from-config
#
#   Parses configuration, extracts the config variables and appends them
#   to Options_webera in the right format, using the provided arguments.
#
# > $1 : the origin of the option, as a prefix: [vdef|args|file|strn]
# > $2 : the path of the configuration (only for files)
# > $3 : the contents of the configuration
# ^ webera::read-config
#
webera::store-options-from-config() {

	local var_orig="$1" config_path="$2" config_content="$3"
	local option_line   # the option line
	local option_name   # the name of the option
	local option_value  # the value of the option

	local __ifs="$IFS"; IFS=$'\n'
	for option_line in $(printf '%s' "$config_content" \
		| $__GREP '^config' \
		| cut -d ':' -f2- \
		| $__SED "s/$__Ws*:$__Ws*/=/" \
		| $__SED "$__Sed_trim_ws" \
		); do
		if [[ $option_line != _* ]]; then # only read public variables
			option_name="${option_line%=*}"
			option_value="${option_line#*=}"
			option_line="${option_name^^}=$option_value"
			Options_webera+=$'\n'"[$var_orig]:$config_path:$option_line"
		fi
	done
	IFS="$__ifs"

} # ::store-options-from-config


#-------------------------------------------------------------------------------
# ::elapsed-time
#
#   Prints the spent time on the script, in milliseconds.
#
# > $1 : if true, prints the time beautified
#
#
webera::elapsed-time() {

	local -ir time_stamp_final="$($__DATE '+%s%3N')"
	local -ir time_elapsed="$((time_stamp_final-__Time_stamp))"
	if [[ $1 == true ]]; then
		printf '%s' "$(webera::beautify-time "$time_elapsed")"
	else
		printf '%s' "$time_elapsed"
	fi

} # ::elapsed-time


#-------------------------------------------------------------------------------
# ::beautify-time
#
#   Tries to format a time in milliseconds into a human readable text string
#   showing the days, hours, minutes and/or seconds contained in that time.
#
# > $1 : time in milliseconds
# e    : time beautified
#
webera::beautify-time() {

	local -ir ms="$1"
	local -ir s="$((ms/1000%60))"
	local -ir m="$((ms/60000%60))"
	local -ir h="$((ms/3600000%24))"
	local -ir d="$((ms/86400000))"

	local time_str; [[ $d -gt 0 ]] && time_str+="${d}d"
	[[ $h -gt 0 || -n $time_str ]] && time_str+="${h}h "
	[[ $m -gt 0 || -n $time_str ]] && time_str+="${m}m "
	[[ -n $time_str ]] && time_str+="${s}s " # show seconds if time > 1m
	[[ $m -lt 1 && -z $time_str ]] && time_str+="${ms}ms "

	printf '%s' "${time_str}"

} # ::beautify-time


[[ $0 == "${BASH_SOURCE[0]}" ]] && webera::main "$@" # Run if not sourced
