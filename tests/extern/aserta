#!/usr/bin/env bash
#
# aserta
# a handy unit testing framework for Bash
#
# Version    : 2.0.0
# Repository : http://github.com/andamira/aserta
# Authors    :
#   - Robert Lehmann © 2009-2015
#   - José Luis Cruz © 2016
# License    : LGPLv3
#

export DISCOVERONLY="${DISCOVERONLY:-}"
export DEBUG="${DEBUG:-}"
export STOP="${STOP:-}"
export INVARIANT="${INVARIANT:-}"
export CONTINUE="${CONTINUE:-}"

args="$(getopt -n "$0" -l \
	verbose,help,stop,discover,invariant,continue vhxdic "$*")" || exit 255

for arg in $args; do
	case "$arg" in
		-h)
			echo "$0 [-vxidc]" \
				"[--verbose] [--stop] [--invariant] [--discover] [--continue]"
			echo "$(sed 's/./ /g' <<< "$0") [-h] [--help]"
			exit 0 ;;

		--help)
			cat <<- EOF
			Usage: $0 [options]
			Language-agnostic unit tests for subprocesses.

			Options:
			  -v, --verbose    generate output for every individual test case
			  -x, --stop       stop running tests after the first failure
			  -i, --invariant  do not measure timings to remain invariant between runs
			  -d, --discover   collect test suites only, do not run any tests
			  -c, --continue   do not modify exit code to test suite status
			  -h               show brief usage information and exit
			  --help           show this help message and exit
			EOF
			exit 0 ;;

		-v|--verbose)
			DEBUG=1 ;;

		-x|--stop)
			STOP=1 ;;

		-i|--invariant)
			INVARIANT=1 ;;

		-d|--discover)
			DISCOVERONLY=1 ;;

		-c|--continue)
			CONTINUE=1 ;;
	esac
done

_indent=$'\n\t' # local format helper

_assert_reset() {
	tests_ran=0
	tests_failed=0
	tests_errors=()
	tests_starttime="$(date +%s%N)" # nanoseconds_since_epoch
}


# assert_end [suite ..]
assert_end() {
	tests_endtime="$(date +%s%N)"

	# required visible decimal place for seconds (leading zeros if needed)
	local tests_time; tests_time="$( printf "%010d" \
		"$(( ${tests_endtime/%N/000000000}
			- ${tests_starttime/%N/000000000} ))")"  # in ns
	tests="$tests_ran ${*:+$* }tests"

	[[ -n "$DISCOVERONLY" ]] && echo "collected $tests." \
		&& _assert_reset && return
	[[ -n "$DEBUG" ]] && echo

	# to get report_time split tests_time on 2 substrings:
	#   ${tests_time:0:${#tests_time}-9} - seconds
	#   ${tests_time:${#tests_time}-9:3} - milliseconds
	if [[ -z "$INVARIANT" ]]; then
		report_time=" in ${tests_time:0:${#tests_time}-9}.${tests_time:${#tests_time}-9:3}s"
	else report_time=; fi

	if [[ "$tests_failed" -eq 0 ]]; then
		echo "all $tests passed$report_time."
	else
		for error in "${tests_errors[@]}"; do echo "$error"; done
		echo "$tests_failed of $tests failed$report_time."
	fi

	tests_ran_total=$((tests_ran_total + tests_ran))
	tests_failed_total=$((tests_failed_total + tests_failed))
	[[ $tests_failed -gt 0 ]] && tests_suite_status=1
	_assert_reset
}


# assert <command> <expected stdout> [stdin]
assert() {
	(( tests_ran++ )) || :
	[[ -z "$DISCOVERONLY" ]] || return
	expected=$(echo -ne "${2:-}")
	result=$(echo -e "$(eval 2>/dev/null "$1" <<< "${3:-}")")
	if [[ "$result" == "$expected" ]]; then
		[[ -z "$DEBUG" ]] || echo -n .
		return
	fi
	result="$(sed -e :a -e '$!N;s/\n/\\n/;ta' <<< "$result")"
	[[ -z "$result" ]] && result="nothing" || result="\"$result\""
	[[ -z "$2" ]] && expected="nothing" || expected="\"$2\""
	_assert_fail "expected $expected${_indent}got $result" "$1" "${3:-}"
}


# assert_raises <command> <expected code> [stdin]
assert_raises() {
	(( tests_ran++ )) || :
	[[ -z "$DISCOVERONLY" ]] || return
	status=0
	(eval "$1" <<< "${3:-}") > /dev/null 2>&1 || status="$?"
	expected=${2:-0}
	if [[ "$status" -eq "$expected" ]]; then
		[[ -z "$DEBUG" ]] || echo -n .
		return
	fi
	_assert_fail "program terminated with code $status instead of $expected" \
		"$1" "$3"
}


# _assert_fail <failure> <command> <stdin>
_assert_fail() {
	[[ -n "$DEBUG" ]] && echo -n X
	report="test #$tests_ran \"$2${3:+ <<< $3}\" failed:${_indent}$1"
	if [[ -n "$STOP" ]]; then
		[[ -n "$DEBUG" ]] && echo
		echo "$report"
		exit 1
	fi
	tests_errors[$tests_failed]="$report"
	(( tests_failed++ )) || :
	return 1
}


# skip_if <command ..>
skip_if() {
	(eval "$@") > /dev/null 2>&1 && status=0 || status="$?"
	[[ "$status" -eq 0 ]] || return
	skip
}


# skip (no arguments)
skip() {
	shopt -q extdebug && tests_extdebug=0 || tests_extdebug=1
	shopt -q -o errexit && tests_errexit=0 || tests_errexit=1

	# enable extdebug so returning 1 in a DEBUG trap handler skips next command
	shopt -s extdebug

	# disable errexit (set -e) so we can safely return 1 without causing exit
	set +o errexit
	tests_trapped=0
	trap _skip DEBUG
}

_skip() {
	if [[ $tests_trapped -eq 0 ]]; then
		# DEBUG trap for command we want to skip.  Do not remove the handler
		# yet because *after* the command we need to reset extdebug/errexit (in
		# another DEBUG trap.)
		tests_trapped=1
		[[ -z "$DEBUG" ]] || echo -n s
		return 1
	else
		trap - DEBUG
		[[ $tests_extdebug -eq 0 ]] || shopt -u extdebug
		[[ $tests_errexit -eq 1 ]] || set -o errexit
		return 0
	fi
}


_assert_reset
: ${tests_suite_status:=0}  # remember if any of the tests failed so far
: ${tests_ran_total:=0}	    # remember total number of tests (inc. failures)
: ${tests_failed_total:=0}  # remember the total number of test failures

_assert_cleanup() {
	local status=$?
	# modify exit code if it's not already non-zero
	[[ $status -eq 0 && -z $CONTINUE ]] && exit $tests_suite_status
}

trap _assert_cleanup EXIT


# assert_success <command> [stdin]
assert_success() {
	assert_raises "$1" 0 "${2:-}"
}

# assert_failure <command> [stdin]
assert_failure() {
	(( tests_ran++ )) || :
	[[ -z "$DISCOVERONLY" ]] || return
	status=0
	(eval "$1" <<< "${2:-}") > /dev/null 2>&1 || status="$?"
	if [[ "$status" != "0" ]]; then
		[[ -z "$DEBUG" ]] || echo -n .
		return
	fi
	_assert_fail "program terminated with a zero return code; expecting non-zero return code" \
		"$1" "$2"
}

# assert_contains <command> <expected output...>
assert_contains() {
	_assert_with_grep '-F' "$@"
}

# assert_matches <command> <expected output...>
assert_matches() {
	_assert_with_grep '-E' "$@"
}

# assert_startswith <command> <expected start to stdout>
assert_startswith() {
	assert_success "[[ '$($1)' == '$2'* ]]"
}

# assert_endswith <command> <expected end to stdout>
assert_endswith() {
	assert_success "[[ '$($1)' == *'$2' ]]"
}

# _assert_with_grep <grep modifiers> <command> <expected output...>
_assert_with_grep() {
	local grep_modifier="$1"
	local output; output="$($2)"
	shift 2

	while [ $# != 0 ]; do
		assert_raises "echo '$output' | $GREP $grep_modifier '$1'" 0 || return 1
		shift
	done
}

# Returns the resolved command, preferring any gnu-versions of the cmd (prefixed with 'g') on
# non-Linux systems such as Mac OS, and falling back to the standard version if not.
_cmd() {
	declare cmd gnu_cmd gnu_cmd_found

	cmd="$1"
	gnu_cmd="g$cmd"
	gnu_cmd_found=$(which "$gnu_cmd" 2> /dev/null)

	if [ "$gnu_cmd_found" ]; then
		echo "$gnu_cmd_found"
	else
		if [ "$(uname)" == 'Darwin' ]; then
			echo "Warning: Cannot find gnu version of command '$cmd' ($gnu_cmd) on path." \
				"Falling back to standard command" >&2
		fi
		echo "$cmd"
	fi
}

GREP=$(_cmd grep)
